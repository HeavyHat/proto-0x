Implement  proper lexical scoping for let expressions.
	- Can the call action be modified to automatically create a proper lexical scope?

Think about basic actions.
	- Is the interface correct?
	-  Maybe the environment should be the second parameter ans state should be third.
	- Should the local variable scope be part of the environment, or should it be a
	  fourth parameter?
	- Should *all* environment variables be part of a scope? Should we allow
	  non-environments in the environments parameter as Proto-current does?

Think about poor SFINAE error reporting cause by too-extensive use of BOOST_PROTO_AUTO_RETURN.

Related to the SFINAE thing: Can something be done about deep template instantion backtraces?
Would it be possible to use something like Haskell's Either monad to transport the offending
code closer to Proto's API boundary?

Thoughts about construct(foo<some_action<int>>())
	- It doesn't invoke some_action. Should it? With what semantics? Is it right to be looking
	  for a nested ::type after substitution, or should it be checking for action-ness instead
	  (or in addtion to)? What would that break?

How about a static_cast_ function object?

Should terminal-ness really be encoded in the tag?

Functional namespace should be carved up: proto::functional::fusion? proto::functional::std?

Should or_/when be renamed match/case_?

Everyplace where we directly return an rvalue reference is potentially creating a dangling
reference.
